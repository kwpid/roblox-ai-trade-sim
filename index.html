<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Roblox Item Distributor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      /* Roblox Dark Mode Palette */
      --primary-text: #CBCBCB;
      --background-main: #111217;
      --background-panel: #222222;
      --background-card: #292929;
      --accent-blue: #2BB1FF;
      --danger-red: #F4645D;
      --success-green: #00E87E;
      --highlight-pink: #FA6C8D;

      /* Grayscale */
      --gray-light: #B7B7B7;
      --gray-mid-light: #848484;
      --gray-mid: #515151;
      --gray-dark: #2D2D2D;
      --gray-darker: #252525;

      --border-color: var(--gray-mid);
      
      /* Utility */
      --font-main: 'Segoe UI', 'Roboto', 'Arial', sans-serif;
      --radius: 8px;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    body {
      background-color: var(--background-main);
      color: var(--primary-text);
      font-family: var(--font-main);
      margin: 0;
      padding: 0;
      font-size: 16px;
    }

    header {
      background-color: var(--background-panel);
      padding: 15px 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border-color);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      position: sticky;
      top: 0;
      z-index: 1001; /* High z-index for header */
    }

    .logo {
      font-size: 28px;
      font-weight: bold;
      color: var(--accent-blue);
    }

    nav {
      display: flex;
      gap: 15px;
    }

    nav button {
      background: none;
      border: none;
      color: var(--primary-text);
      font-size: 16px;
      padding: 10px 20px;
      cursor: pointer;
      border-radius: var(--radius);
      transition: background-color 0.2s, color 0.2s;
      font-weight: 600;
    }

    nav button:hover {
      background-color: var(--gray-dark);
      color: var(--accent-blue);
    }

    nav button.active {
      background-color: var(--accent-blue);
      color: #fff;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 25px;
    }

    .tab-content {
      display: none;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .tab-content.active {
      display: block;
    }

    /* Common UI Elements */
    .marketplace-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 1px solid var(--border-color);
    }

    .btn {
      background-color: var(--accent-blue);
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: var(--radius);
      cursor: pointer;
      font-weight: bold;
      transition: all 0.2s;
      font-size: 16px;
    }

    .btn:hover {
      background-color: #1a9de8; /* Slightly lighter blue */
      transform: translateY(-2px);
    }

    .btn-secondary {
      background-color: var(--gray-mid);
      color: var(--primary-text);
    }

    .btn-secondary:hover {
      background-color: var(--gray-mid-light);
    }

    .btn-danger {
      background-color: var(--danger-red);
    }

    .btn-danger:hover {
      background-color: #f24e46; /* Lighter red */
    }

    .btn-warning {
      background-color: #ff9800; /* Reusing old orange as no new one was provided */
    }

    .btn-warning:hover {
      background-color: #e68a00;
    }

    .item-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 25px;
    }

    .item-card {
      background-color: var(--background-card);
      border-radius: var(--radius);
      overflow: hidden;
      box-shadow: var(--shadow);
      transition: transform 0.2s, box-shadow 0.2s;
      border: 1px solid var(--gray-dark);
      position: relative;
    }

    .item-card:hover {
      transform: translateY(-5px);
      border-color: var(--accent-blue);
    }

    .item-image {
      width: 100%;
      height: 200px;
      object-fit: cover;
      border-bottom: 1px solid var(--gray-dark);
    }

    .item-details { padding: 18px; }
    .item-name {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--primary-text);
    }
    .item-value { color: var(--success-green); font-weight: bold; font-size: 18px; margin-bottom: 8px; }
    .item-rap { display: none; /* RAP is being removed */ }
    
    .item-stock { display: flex; align-items: center; margin-bottom: 8px; font-size: 14px; color: var(--gray-light); }
    .stock-bar { flex-grow: 1; height: 8px; background-color: var(--gray-darker); border-radius: 4px; margin-left: 10px; overflow: hidden; }
    .stock-fill { height: 100%; background-color: var(--accent-blue); width: 100%; }
    
    .item-owners { font-size: 14px; color: var(--gray-light); margin-top: 10px; }
    .item-timer { font-size: 14px; font-weight: bold; color: var(--danger-red); margin-top: 10px; text-align: center; background-color: rgba(244, 100, 93, 0.1); padding: 5px; border-radius: 4px; }
    .item-actions { display: flex; gap: 8px; margin-top: 15px; }

    .item-status {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: var(--accent-blue);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
    }

    /* Leaderboard */
    .leaderboard-tabs { display: flex; gap: 10px; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
    .leaderboard-tab { padding: 10px 20px; background-color: var(--background-card); border: none; border-radius: var(--radius); color: var(--primary-text); cursor: pointer; transition: all 0.2s; font-weight: 600; }
    .leaderboard-tab.active { background-color: var(--accent-blue); color: white; }
    .leaderboard-tab:hover { background-color: var(--gray-dark); }
    
    .leaderboard-table { width: 100%; border-collapse: collapse; border-radius: var(--radius); overflow: hidden; }
    .leaderboard-table th { background-color: var(--background-panel); padding: 15px; text-align: left; font-weight: bold; }
    .leaderboard-table td { padding: 15px; border-bottom: 1px solid var(--border-color); background-color: var(--background-card); }
    .leaderboard-table tr:hover td { background-color: var(--gray-dark); }
    
    .leaderboard-rank { font-weight: bold; color: var(--accent-blue); width: 50px; }
    .leaderboard-name { font-weight: bold; }
    .leaderboard-value { color: var(--success-green); font-weight: bold; }
    .leaderboard-rap { display: none; /* RAP is being removed */ }

    /* Popups */
    .popup-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.8); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
    .popup-overlay.active { opacity: 1; pointer-events: all; }
    .popup-content { background-color: var(--background-panel); border-radius: var(--radius); width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto; padding: 30px; box-shadow: var(--shadow); transform: translateY(20px); transition: transform 0.3s; border: 1px solid var(--border-color); }
    .popup-overlay.active .popup-content { transform: translateY(0); }
    .popup-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
    .popup-title { font-size: 24px; font-weight: bold; margin: 0; color: var(--accent-blue); }
    .popup-close { background: none; border: none; color: var(--gray-light); font-size: 28px; cursor: pointer; padding: 0; line-height: 1; transition: color 0.2s; }
    .popup-close:hover { color: var(--primary-text); }

    /* Forms */
    .form-group { margin-bottom: 20px; }
    .form-label { display: block; margin-bottom: 8px; font-weight: bold; color: var(--primary-text); }
    .form-control { width: 100%; padding: 12px; background-color: var(--gray-darker); border: 1px solid var(--border-color); border-radius: var(--radius); color: var(--primary-text); font-size: 16px; transition: border-color 0.2s; }
    .form-control:focus { outline: none; border-color: var(--accent-blue); }
    
    .popup-footer { display: flex; justify-content: flex-end; gap: 15px; margin-top: 30px; padding-top: 20px; border-top: 1px solid var(--border-color); }

    /* AI Profile */
    .ai-profile { text-align: center; }
    .ai-avatar { width: 120px; height: 120px; border-radius: 50%; background-color: var(--accent-blue); margin: 0 auto 20px; display: flex; align-items: center; justify-content: center; font-size: 48px; font-weight: bold; border: 3px solid var(--accent-blue); }
    .ai-stats { display: flex; justify-content: space-around; margin: 30px 0; background-color: var(--background-card); padding: 20px; border-radius: var(--radius); }
    .stat-box { text-align: center; padding: 0 15px; }
    .stat-value { font-size: 28px; font-weight: bold; color: var(--accent-blue); margin-bottom: 5px; }
    .stat-label { font-size: 16px; color: var(--gray-light); }
    
    .ai-inventory { margin-top: 20px; }
    .inventory-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
    #ai-inventory-items { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 20px; max-height: 350px; overflow-y: auto; padding: 5px; }
    
    .badge-container { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin: 20px 0; }
    .badge { background-color: var(--background-card); color: var(--primary-text); padding: 5px 12px; border-radius: 15px; font-size: 12px; font-weight: bold; border: 1px solid var(--border-color); display: flex; align-items: center; gap: 6px; }
    .badge.rank-badge { border-color: var(--accent-blue); }
    .badge.value-badge { border-color: var(--success-green); }
    .badge.item-badge { border-color: var(--highlight-pink); }

    .inventory-item { background-color: var(--gray-dark); border-radius: var(--radius); padding: 15px; text-align: center; transition: transform 0.2s; border: 1px solid var(--gray-mid); position: relative; }
    .inventory-item:hover { transform: translateY(-3px); border-color: var(--accent-blue); }
    .inventory-item img { width: 100%; height: 100px; object-fit: cover; border-radius: 6px; margin-bottom: 12px; border: 1px solid var(--gray-mid); }
    .inventory-item-limited-icon { position: absolute; top: 90px; left: 20px; font-size: 24px; text-shadow: 0 0 5px rgba(0,0,0,0.8); pointer-events: none; }
    .inventory-item-name { font-size: 16px; font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 5px; }
    .inventory-item-value { font-size: 14px; color: var(--success-green); margin-bottom: 5px; }
    .inventory-item-rap { font-size: 14px; color: var(--highlight-pink); margin-bottom: 5px; }
    .inventory-item-serial { font-size: 12px; color: var(--gray-light); margin-top: 8px; }

    /* Reports */
    .report-list { display: flex; flex-direction: column; gap: 15px; }
    .report-card { background-color: var(--background-card); border-radius: var(--radius); padding: 20px; border-left: 5px solid #ff9800; cursor: pointer; transition: background-color 0.2s, border-color 0.2s; }
    .report-card:hover { background-color: var(--gray-dark); border-left-color: var(--accent-blue); }
    .report-card.unread { border-left-color: var(--danger-red); }
    .report-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .report-user { font-weight: bold; font-size: 18px; }
    .report-time { font-size: 14px; color: var(--gray-light); }
    .report-reason { font-style: italic; }

    /* Ban Land */
    .ban-land-list { width: 100%; border-collapse: collapse; }
    .ban-land-list th, .ban-land-list td { padding: 15px; border-bottom: 1px solid var(--border-color); text-align: left; }
    .ban-land-list th { background-color: var(--background-panel); }
    .ban-land-list tr:hover td { background-color: var(--gray-dark); }

    /* Trades */
    .trade-history-list { width: 100%; border-collapse: collapse; }
    .trade-history-list td { padding: 15px; border-bottom: 1px solid var(--border-color); vertical-align: top; }
    .trade-participants { font-weight: bold; }
    .trade-items { display: flex; flex-direction: column; gap: 8px; font-size: 14px; }
    .trade-item { display: flex; align-items: center; gap: 8px; }
    .trade-item img { width: 32px; height: 32px; border-radius: 4px; }
    .trade-total { margin-top: 10px; font-weight: bold; font-size: 14px; text-align: right; padding-top: 8px; border-top: 1px solid var(--gray-dark); }
    .trade-card { background-color: var(--background-card); border-radius: var(--radius); padding: 20px; margin-bottom: 15px; display: flex; align-items: center; gap: 20px; }
    .trade-side { flex: 1; }
    .trade-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .trade-card-user { font-size: 18px; font-weight: bold; }

    /* Admin Panel */
    .admin-panel-form { display: flex; flex-direction: column; gap: 20px; max-width: 500px; background-color: var(--background-card); padding: 25px; border-radius: var(--radius); }
    .settings-panel { display: flex; flex-direction: column; gap: 20px; max-width: 500px; }

    /* Indicators */
    .nav-button-container { position: relative; }
    .report-indicator { position: absolute; top: 5px; right: 5px; width: 10px; height: 10px; background-color: var(--danger-red); border-radius: 50%; display: none; }
    .report-indicator.active { display: block; }

    /* Chart.js overrides */
    #item-stats-demand { color: var(--accent-blue) !important; font-weight: bold;}
    #item-stats-op { color: var(--success-green) !important; font-weight: bold;}

    .value-history-chart-container,
    .ai-chart-container {
        position: relative;
        height: 250px;
        width: 100%;
        background-color: var(--background-card);
        border-radius: var(--radius);
        padding: 15px;
    }

    /* Responsive styles - simplified for brevity */
    @media (max-width: 768px) {
      header { flex-direction: column; gap: 15px; padding: 15px; }
      nav { width: 100%; justify-content: center; flex-wrap: wrap; }
      .item-grid { grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); }
      .ai-stats { flex-direction: column; gap: 20px; }
    }
    
    @media (max-width: 480px) {
      .item-grid {
        grid-template-columns: 1fr;
      }
      .popup-content { padding: 20px; }
      .leaderboard-table th, .leaderboard-table td { padding: 10px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="logo">Roblox Item Distributor</div>
    <nav>
      <button class="active" onclick="switchTab('marketplace')">Marketplace</button>
      <button onclick="switchTab('leaderboard')">Leaderboards</button>
      <div class="nav-button-container">
        <button onclick="switchTab('reports')">Reports</button>
        <div id="report-indicator" class="report-indicator"></div>
      </div>
      <button onclick="switchTab('ban-land')">Ban Land</button>
      <button onclick="switchTab('trades')">Trades</button>
      <button onclick="switchTab('admin-panel')">Admin Panel</button>
    </nav>
  </header>

  <div class="container">
    <!-- Marketplace Tab -->
    <div id="marketplace" class="tab-content active">
      <div class="marketplace-header">
        <h2>Marketplace</h2>
        <input type="text" id="marketplace-search-input" class="form-control" placeholder="Search items..." style="max-width: 300px; margin-left: auto; margin-right: 20px;">
        <button class="btn" onclick="openItemPopup()">+ Release Item</button>
      </div>
      <div class="item-grid" id="item-list">
        <!-- Items will be dynamically inserted here -->
      </div>
    </div>

    <!-- Leaderboard Tab -->
    <div id="leaderboard" class="tab-content">
      <h2>Leaderboards</h2>
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 15px;">
        <div class="leaderboard-tabs">
          <button class="leaderboard-tab active" onclick="switchLeaderboard('value')">Value</button>
          <button class="leaderboard-tab" onclick="switchLeaderboard('rap')" style="display: none;">RAP</button>
          <button class="leaderboard-tab" onclick="switchLeaderboard('items')">Items</button>
        </div>
        <input type="text" id="leaderboard-search-input" class="form-control" placeholder="Search users..." style="max-width: 300px;">
      </div>
      <table class="leaderboard-table">
        <thead>
          <tr>
            <th style="width: 60px;">Rank</th>
            <th>Username</th>
            <th id="leaderboard-header">Value</th>
            <th style="width: 100px;">Items</th>
          </tr>
        </thead>
        <tbody id="leaderboard-list">
          <!-- Leaderboard entries will be dynamically inserted here -->
        </tbody>
      </table>
    </div>

    <!-- Reports Tab -->
    <div id="reports" class="tab-content">
        <div class="marketplace-header">
            <h2>Reports</h2>
            <button class="btn btn-warning" onclick="generateRandomReport()">+ Generate Report</button>
        </div>
        <div id="report-list" class="report-list">
            <!-- Reports will be dynamically inserted here -->
        </div>
    </div>

    <!-- Ban Land Tab -->
    <div id="ban-land" class="tab-content">
        <h2>Ban Land</h2>
        <table id="banned-user-list" class="ban-land-list">
            <thead>
                <tr>
                    <th>Username</th>
                    <th>Ban Date</th>
                    <th>Original Item Count</th>
                    <th>Original Value</th>
                </tr>
            </thead>
            <tbody>
                <!-- Banned users will be dynamically inserted here -->
            </tbody>
        </table>
    </div>

    <!-- Trades Tab -->
    <div id="trades" class="tab-content">
        <h2>Trade History</h2>
        <input type="text" id="trade-history-search" class="form-control" placeholder="Search trades by username..." style="max-width: 300px; margin-bottom: 15px;">
        <div id="trade-history-list">
            <!-- Trade history will be dynamically inserted here -->
        </div>
    </div>

    <!-- Admin Panel Tab -->
    <div id="admin-panel" class="tab-content">
      <h2>Admin Panel</h2>
      <div class="admin-panel-form">
        <div class="form-group">
          <label class="form-label" for="admin-user-id">User ID</label>
          <input type="number" id="admin-user-id" class="form-control" placeholder="Enter User ID">
        </div>
        <div class="form-group">
          <label class="form-label" for="admin-item-select">Item</label>
          <select id="admin-item-select" class="form-control"></select>
        </div>
        <button class="btn" onclick="adminGiveItem()">Give Item to User</button>
      </div>
    </div>

    <!-- Settings Tab -->
    <div id="settings" class="tab-content">
      <h2>Settings</h2>
      <div class="settings-panel">
        <p>Export all current simulation data to a file. You can import this file later to restore the state.</p>
        <button class="btn" onclick="exportData()">Export All Data</button>
        <hr style="border-color: var(--border-color); width: 100%;">
        <p>Import a previously exported data file. This will overwrite the current simulation state.</p>
        <button class="btn btn-secondary" onclick="document.getElementById('import-file-input').click()">Import Data</button>
        <input type="file" id="import-file-input" style="display: none;" accept=".json" onchange="importData(event)">
      </div>
    </div>
  </div>

  <!-- Release Item Popup -->
  <div class="popup-overlay" id="item-popup">
    <div class="popup-content">
      <div class="popup-header">
        <h3 class="popup-title" id="item-popup-title">Release New Item</h3>
        <button class="popup-close" onclick="closeItemPopup()">&times;</button>
      </div>
      <div class="form-group">
        <label class="form-label">Image Source</label>
        <div style="display: flex; gap: 20px;">
            <label style="cursor: pointer;"><input type="radio" name="image-source" value="upload" checked onchange="toggleImageSource(this.value)"> Upload</label>
            <label style="cursor: pointer;"><input type="radio" name="image-source" value="url" onchange="toggleImageSource(this.value)"> URL</label>
        </div>
      </div>
      <div id="image-upload-group" class="form-group">
        <label class="form-label" for="item-image">Item Image</label>
        <input type="file" id="item-image" class="form-control" accept="image/*">
      </div>
      <div id="image-url-group" class="form-group" style="display: none;">
          <label class="form-label" for="item-image-url">Item Image URL</label>
          <input type="text" id="item-image-url" class="form-control" placeholder="https://example.com/image.png">
      </div>
      <div class="form-group">
        <label class="form-label" for="item-name">Item Name</label>
        <input type="text" id="item-name" class="form-control" placeholder="Cool Hat">
      </div>

      <div id="collectible-fields">
        <div class="form-group">
          <label class="form-label" for="item-value">Initial Price (R$)</label>
          <input type="number" id="item-value" class="form-control" placeholder="1000" min="1">
        </div>
        <div class="form-group" style="display: none;">
          <label class="form-label" for="item-rap">Determined RAP (R$)</label>
          <input type="number" id="item-rap" class="form-control" placeholder="800" min="1">
        </div>
        <div class="form-group">
          <label class="form-label" for="stock">Stock</label>
          <input type="number" id="stock" class="form-control" placeholder="100" min="1">
        </div>
      </div>
      
      <div class="popup-footer">
        <button class="btn" id="item-popup-submit" onclick="handleItemSubmit()">Release Item</button>
        <button class="btn btn-secondary" onclick="closeItemPopup()">Cancel</button>
      </div>
    </div>
  </div>

  <!-- AI Profile Popup -->
  <div class="popup-overlay" id="ai-popup">
    <div class="popup-content">
      <div class="popup-header">
        <h3 class="popup-title" id="ai-profile-name">AI Profile</h3>
        <button class="popup-close" onclick="closeAIPopup()">&times;</button>
      </div>
      <div class="ai-profile">
        <div class="ai-avatar" id="ai-avatar">A</div>
        <div id="ai-badge-container" class="badge-container">
          <!-- Badges will be inserted here -->
        </div>
        <div class="ai-stats">
          <div class="stat-box">
            <div class="stat-value" id="ai-value">0</div>
            <div class="stat-label">Value</div>
          </div>
          <div class="stat-box">
            <div class="stat-value" id="ai-rap">0</div>
            <div class="stat-label">RAP</div>
          </div>
          <div class="stat-box">
            <div class="stat-value" id="ai-items">0</div>
            <div class="stat-label">Items</div>
          </div>
        </div>
        <div class="ai-inventory">
          <div class="inventory-header">
            <h4>Inventory (<span id="ai-inventory-count">0</span>)</h4>
          </div>
          <input type="text" id="ai-inventory-search" class="form-control" placeholder="Search inventory..." style="margin-bottom: 10px;">
          <div class="inventory-grid" id="ai-inventory-items">
            <!-- AI inventory items will be inserted here -->
          </div>
        </div>
        <div style="margin-top: 30px; display: flex; gap: 30px; flex-wrap: wrap; justify-content: center;">
          <div style="flex: 1; min-width: 250px; max-width: 400px;">
            <h4>Value History</h4>
            <canvas id="ai-value-history-chart"></canvas>
          </div>
          <div style="flex: 1; min-width: 250px; max-width: 400px;">
            <h4>RAP History</h4>
            <canvas id="ai-rap-history-chart"></canvas>
          </div>
        </div>
      </div>
      <div class="popup-footer" id="ai-popup-footer">
        <!-- AI action buttons will be inserted here -->
      </div>
    </div>
  </div>

  <!-- Item Stats Popup -->
  <div class="popup-overlay" id="item-stats-popup">
    <div class="popup-content">
      <div class="popup-header">
        <h3 class="popup-title" id="item-stats-title">Item Statistics</h3>
        <button class="popup-close" onclick="closeItemStatsPopup()">&times;</button>
      </div>
      <div id="item-stats-content" style="display: flex; gap: 30px; margin-top: 20px; flex-wrap: wrap;">
          <div id="item-stats-details" style="flex: 1; min-width: 200px;">
              <h4>Details</h4>
              <p><strong>Demand:</strong> <span id="item-stats-demand" style="color: var(--primary-blue); font-weight: bold;">N/A</span></p>
              <p><strong>Average Overpay:</strong> <span id="item-stats-op" style="color: var(--value-green); font-weight: bold;">N/A</span></p>
              <p><strong>Times Traded:</strong> <span id="item-stats-trades" style="font-weight: bold;">0</span></p>
          </div>
          <div id="item-stats-image" style="flex: 0 0 150px;">
              <img id="item-stats-img-src" style="width: 100%; border-radius: 8px; border: 1px solid var(--border-color);">
          </div>
      </div>
      <div style="margin-top: 25px;">
          <h4>Value History</h4>
          <div class="value-history-chart-container">
            <canvas id="value-history-chart"></canvas>
          </div>
      </div>
    </div>
  </div>

  <script>
// Game State
const marketplace = [];
const aiUsers = generateAIUsers(2500);
let leaderboardType = 'value';
let itemIdCounter = 1;
let currentViewingAI = null;
let editingItemId = null;

// Leaderboard state
let valueLeaderboard = [];
let rapLeaderboard = [];
let itemsLeaderboard = [];

// Report state
const reports = [];
let reportIdCounter = 1;
const bannedUsers = [];
const tradeHistory = [];
let masterTimer;

// DOM Elements
const marketplaceTab = document.getElementById('marketplace');
const leaderboardTab = document.getElementById('leaderboard');
const itemList = document.getElementById('item-list');
const leaderboardList = document.getElementById('leaderboard-list');
const leaderboardHeader = document.getElementById('leaderboard-header');
const itemPopup = document.getElementById('item-popup');
const aiPopup = document.getElementById('ai-popup');
const aiPopupFooter = document.getElementById('ai-popup-footer');
const reportList = document.getElementById('report-list');
const reportIndicator = document.getElementById('report-indicator');
const bannedUserList = document.getElementById('banned-user-list').getElementsByTagName('tbody')[0];
const tradeHistoryList = document.getElementById('trade-history-list');
const adminItemSelect = document.getElementById('admin-item-select');
const itemStatsPopup = document.getElementById('item-stats-popup');
let valueChartInstance = null;

const BADGE_DEFINITIONS = {
    VALUE: [
        { value: 100_000_000, name: '100M+ Value', icon: 'ðŸ’°' },
        { value: 50_000_000, name: '50M+ Value', icon: 'ðŸ’°' },
        { value: 10_000_000, name: '10M+ Value', icon: 'ðŸ’°' },
        { value: 1_000_000, name: '1M+ Value', icon: 'ðŸ’°' },
        { value: 500_000, name: '500K+ Value', icon: 'ðŸ’°' },
        { value: 100_000, name: '100K+ Value', icon: 'ðŸ’°' },
    ],
    RANK: [
        { rank: 1, name: 'Top 1', icon: 'ðŸ¥‡' },
        { rank: 3, name: 'Top 3', icon: 'ðŸ¥‰' },
        { rank: 10, name: 'Top 10', icon: 'â­' },
        { rank: 25, name: 'Top 25', icon: 'â­' },
        { rank: 50, name: 'Top 50', icon: 'â­' },
        { rank: 100, name: 'Top 100', icon: 'â­' },
    ],
    ITEM: [
        { keyword: 'Dominus', name: 'Dominus Owner', icon: 'ðŸ‘‘' },
        { keyword: 'Federation', name: 'Federation Owner', icon: 'ðŸš€' },
        { keyword: 'Sparkle', name: 'Sparkle Time', icon: 'âœ¨' },
    ]
};

function getAIBadges(ai) {
    const badges = [];
    const value = calculateAIValue(ai);

    // Value badges
    for (const badge of BADGE_DEFINITIONS.VALUE) {
        if (value >= badge.value) {
            badges.push({ ...badge, type: 'value-badge' });
            break; 
        }
    }

    // Rank badges
    const valueRank = valueLeaderboard.findIndex(u => u.id === ai.id) + 1;
    const rapRank = rapLeaderboard.findIndex(u => u.id === ai.id) + 1;
    const itemsRank = itemsLeaderboard.findIndex(u => u.id === ai.id) + 1;
    const bestRank = Math.min(
        valueRank > 0 ? valueRank : Infinity,
        rapRank > 0 ? rapRank : Infinity,
        itemsRank > 0 ? itemsRank : Infinity
    );

    if (bestRank !== Infinity) {
         for (const badge of BADGE_DEFINITIONS.RANK) {
            if (bestRank <= badge.rank) {
                badges.push({ ...badge, type: 'rank-badge' });
                break; 
            }
        }
    }

    // Item badges
    const ownedItemNames = new Set(ai.inventory.map(i => i.item.name.toLowerCase()));
    const awardedItemBadges = new Set();
    
    for (const badge of BADGE_DEFINITIONS.ITEM) {
        if (awardedItemBadges.has(badge.name)) continue;

        for (const itemName of ownedItemNames) {
            if (itemName.includes(badge.keyword.toLowerCase())) {
                badges.push({ ...badge, type: 'item-badge' });
                awardedItemBadges.add(badge.name);
                break;
            }
        }
    }

    return badges;
}

// ROBLOX Admin Account
const robloxAdmin = {
  id: 0,
  name: "ROBLOX",
  inventory: [],
  economicClass: 1, // Max economic class for higher chance of rare items if ever needed
  isAdmin: true
};
aiUsers.unshift(robloxAdmin);

function banAI(aiToBan) {
  if (aiToBan.isAdmin) {
    alert("Cannot ban the admin account.");
    return;
  }
  
  const admin = aiUsers.find(ai => ai.isAdmin);
  const inventorySnapshot = [...aiToBan.inventory];

  if (admin && aiToBan.inventory.length > 0) {
    admin.inventory.push(...aiToBan.inventory);
  }

  const userIndex = aiUsers.findIndex(user => user.id === aiToBan.id);
  if (userIndex > -1) {
    const [bannedUser] = aiUsers.splice(userIndex, 1);

    bannedUsers.unshift({
        ...bannedUser,
        inventory: [], // Clear their live inventory
        bannedInventory: inventorySnapshot,
        banDate: new Date(),
        isBanned: true,
    });
  }

  closeAIPopup();
  updateAllLeaderboards();
  renderBanLand();
  alert(`${aiToBan.name} has been banned. Their items have been transferred to ${admin.name}.`);
}

function unbanAI(userToUnban, restoreItems) {
    const bannedUserIndex = bannedUsers.findIndex(u => u.id === userToUnban.id);
    if (bannedUserIndex === -1) return;

    const [unbannedUser] = bannedUsers.splice(bannedUserIndex, 1);

    // Clean up banned properties
    delete unbannedUser.isBanned;
    delete unbannedUser.banDate;
    
    if (restoreItems) {
        const admin = aiUsers.find(ai => ai.isAdmin);
        const itemsToRestore = [...unbannedUser.bannedInventory];
        
        unbannedUser.inventory = itemsToRestore;

        if (admin) {
             const restoredSerials = new Set(itemsToRestore.map(i => `${i.item.id}-${i.serialNumber}`));
             admin.inventory = admin.inventory.filter(i => !restoredSerials.has(`${i.item.id}-${i.serialNumber}`));
        }
    } else {
        unbannedUser.inventory = [];
    }

    delete unbannedUser.bannedInventory;
    aiUsers.push(unbannedUser);

    closeAIPopup();
    updateAllLeaderboards();
    renderBanLand();
    alert(`${unbannedUser.name} has been unbanned.`);
}

function renderBanLand() {
    bannedUserList.innerHTML = '';
    if (bannedUsers.length === 0) {
        bannedUserList.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 40px; color: var(--text-secondary);">No users have been banned.</td></tr>';
        return;
    }
    
    bannedUsers.forEach(user => {
        const row = document.createElement('tr');
        row.onclick = () => openAIPopup(user);

        const originalValue = user.bannedInventory.reduce((sum, i) => sum + i.item.value, 0);

        row.innerHTML = `
            <td>${user.name}</td>
            <td>${user.banDate.toLocaleDateString()} ${user.banDate.toLocaleTimeString()}</td>
            <td>${user.bannedInventory.length}</td>
            <td class="leaderboard-value">R$ ${originalValue.toLocaleString()}</td>
        `;
        bannedUserList.appendChild(row);
    });
}

function updateAdminName(newName) {
  const admin = aiUsers.find(ai => ai.isAdmin);
  if (admin) {
    admin.name = newName;
    updateAllLeaderboards();
  }
}

// Tab Switching
function switchTab(tabId) {
  document.querySelectorAll('nav button, .nav-button-container button').forEach(btn => {
    btn.classList.remove('active');
  });
  
  const targetButton = document.querySelector(`button[onclick="switchTab('${tabId}')"]`);
  if (targetButton) {
      targetButton.classList.add('active');
  }

  document.querySelectorAll('.tab-content').forEach(tab => {
    tab.classList.remove('active');
  });
  document.getElementById(tabId).classList.add('active');

  if (tabId === 'reports') {
      reportIndicator.classList.remove('active');
      reports.forEach(r => r.isUnread = false);
      renderReports();
  } else if (tabId === 'ban-land') {
      renderBanLand();
  } else if (tabId === 'trades') {
      renderTradeHistory();
  } else if (tabId === 'admin-panel') {
      renderAdminPanel();
  }
}

// Leaderboard Switching
function switchLeaderboard(type) {
  leaderboardType = type;
  
  document.querySelectorAll('.leaderboard-tab').forEach(tab => {
    tab.classList.remove('active');
  });
  document.querySelector(`.leaderboard-tab[onclick="switchLeaderboard('${type}')"]`).classList.add('active');
  
  switch(type) {
    case 'value':
      leaderboardHeader.textContent = 'Value';
      break;
    case 'rap':
      // This case is now obsolete but left for safety.
      leaderboardHeader.textContent = 'RAP';
      break;
    case 'items':
      leaderboardHeader.textContent = 'Items';
      break;
  }
  
  renderLeaderboard(document.getElementById('leaderboard-search-input').value);
}

// Popup Controls
function openItemPopup(item = null) {
  editingItemId = item ? item.id : null;
  
  document.getElementById('item-popup-title').textContent = item ? 'Edit Item' : 'Release New Item';
  document.getElementById('item-popup-submit').textContent = item ? 'Update Item' : 'Release Item';

  // Clear all fields first
  document.getElementById('item-image').value = '';
  document.getElementById('item-image-url').value = '';
  document.getElementById('item-name').value = '';
  document.getElementById('item-value').value = '';
  document.getElementById('item-rap').value = '';
  document.getElementById('stock').value = '';
  
  if (item) {
    // Pre-fill for editing
    document.getElementById('item-name').value = item.name;
    document.getElementById('item-value').value = item.value;
    document.getElementById('item-rap').value = item.rap;
    document.getElementById('stock').value = item.initialStock;
  }
  
  // Reset image source toggle
  document.querySelector('input[name="image-source"][value="upload"]').checked = true;
  toggleImageSource('upload');
  
  itemPopup.classList.add('active');
}

function closeItemPopup() {
  itemPopup.classList.remove('active');
  editingItemId = null;
}

function openAIPopup(ai) {
  currentViewingAI = ai;
  const aiProfileName = document.getElementById('ai-profile-name');
  
  const idDisplay = ai.isBanned ? ` (Banned ID: ${ai.id})` : ` (ID: ${ai.id})`;

  if (ai.isAdmin && !ai.isBanned) {
    aiProfileName.innerHTML = `<input type="text" value="${ai.name}" id="admin-name-input" class="form-control" style="display: inline-block; width: auto; font-size: 24px; padding: 5px 10px; height: auto;"> ${idDisplay}`;
    const adminNameInput = document.getElementById('admin-name-input');
    adminNameInput.addEventListener('change', (e) => {
      updateAdminName(e.target.value);
      // Update title without input box after change
      document.getElementById('ai-profile-name').textContent = e.target.value;
      // Refocus to show new name on avatar/stats
      openAIPopup(aiUsers.find(u => u.isAdmin));
    });
  } else {
    aiProfileName.textContent = ai.name + idDisplay;
  }

  document.getElementById('ai-avatar').textContent = ai.name.charAt(0).toUpperCase();
  document.getElementById('ai-avatar').style.backgroundColor = getColorFromName(ai.name);
  
  const inventory = ai.isBanned ? ai.bannedInventory : ai.inventory;
  const value = inventory.reduce((sum, i) => sum + i.item.value, 0);
  const rap = inventory.reduce((sum, i) => sum + i.item.rap, 0);

  document.getElementById('ai-value').textContent = Math.floor(value).toLocaleString();
  document.getElementById('ai-rap').textContent = Math.floor(rap).toLocaleString();
  document.getElementById('ai-items').textContent = inventory.length;
  
  const inventoryGrid = document.getElementById('ai-inventory-items');
  inventoryGrid.innerHTML = '';
  document.getElementById('ai-inventory-count').textContent = inventory.length;

  // Sort inventory by value (highest to lowest)
  const sortedInventory = [...inventory].sort((a, b) => b.item.value - a.item.value);
  
  // --- Inventory Search/Filter ---
  const aiInvSearchInput = document.getElementById('ai-inventory-search');
  aiInvSearchInput.value = '';
  function renderFilteredInventory() {
    const filter = aiInvSearchInput.value.trim().toLowerCase();
    inventoryGrid.innerHTML = '';
    const filtered = filter ? sortedInventory.filter(item =>
      item.item.name.toLowerCase().includes(filter)
    ) : sortedInventory;
    filtered.forEach(item => {
      const itemEl = document.createElement('div');
      itemEl.className = 'inventory-item';
      let limitedIconHTML = '';
      if (item.item.initialStock <= 50) {
          limitedIconHTML = `<div class=\"inventory-item-limited-icon\">ðŸ’Ž</div>`;
      }
      itemEl.innerHTML = `
        ${limitedIconHTML}
        <img src=\"${item.item.image}\" alt=\"${item.item.name}\">\n        <div class=\"inventory-item-name\">${item.item.name}</div>\n        <div class=\"inventory-item-value\">Value: R$ ${item.item.value.toLocaleString()} ${getValuationStatusIcon(item)}</div>\n        <div class=\"inventory-item-rap\" style="display:none;">RAP: R$ ${item.item.rap.toLocaleString()}</div>\n        <div class=\"inventory-item-serial\">#${item.serialNumber}</div>\n      `;
      inventoryGrid.appendChild(itemEl);
    });
    document.getElementById('ai-inventory-count').textContent = filtered.length;
  }
  aiInvSearchInput.oninput = renderFilteredInventory;
  renderFilteredInventory();

  // Render Badges
  const badgeContainer = document.getElementById('ai-badge-container');
  badgeContainer.innerHTML = '';
  // Don't show badges for banned players
  if (!ai.isBanned) {
      const badges = getAIBadges(ai);
      badges.forEach(badge => {
          const badgeEl = document.createElement('div');
          badgeEl.className = `badge ${badge.type}`;
          badgeEl.title = badge.name;
          badgeEl.innerHTML = `${badge.icon} <span>${badge.name}</span>`;
          badgeContainer.appendChild(badgeEl);
      });
  }

  // Add action buttons
  aiPopupFooter.innerHTML = '';
  if (ai.isBanned) {
      aiPopupFooter.innerHTML = `
        <button class="btn" onclick='unbanAI(${JSON.stringify(ai)}, true)'>Unban & Restore Items</button>
        <button class="btn btn-secondary" onclick='unbanAI(${JSON.stringify(ai)}, false)'>Unban Only</button>
      `;
  } else if (!ai.isAdmin) {
    const banButton = document.createElement('button');
    banButton.className = 'btn btn-danger';
    banButton.textContent = `Ban ${ai.name}`;
    banButton.onclick = () => {
      if (confirm(`Are you sure you want to ban ${ai.name}? This is irreversible.`)) {
        banAI(ai);
      }
    };
    aiPopupFooter.appendChild(banButton);
  }
  
  aiPopup.classList.add('active');
}

function closeAIPopup() {
  aiPopup.classList.remove('active');
  currentViewingAI = null;
}

function getColorFromName(name) {
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = name.charCodeAt(i) + ((hash << 5) - hash);
  }
  const h = hash % 360;
  return `hsl(${h}, 70%, 50%)`;
}

// Item Management
function handleItemSubmit() {
  const imageSource = document.querySelector('input[name="image-source"]:checked').value;
  const fileInput = document.getElementById('item-image');
  const imageUrlInput = document.getElementById('item-image-url');
  const nameInput = document.getElementById('item-name');
  
  // Collectible fields
  const valueInput = document.getElementById('item-value');
  const rapInput = document.getElementById('item-rap');
  const stockInput = document.getElementById('stock');

  // --- Image Validation ---
  let imagePromise;

  if (imageSource === 'url') {
    const url = imageUrlInput.value.trim();
    if (url) {
      imagePromise = Promise.resolve(url);
    } else if (!editingItemId) {
      alert('Please enter an image URL');
      return;
    }
  } else { // upload
    if (fileInput.files[0]) {
      imagePromise = new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.onerror = () => reject('Error reading file.');
        reader.readAsDataURL(fileInput.files[0]);
      });
    } else if (!editingItemId) {
      alert('Please select an image for the item');
      return;
    }
  }

  // --- Other Validations ---
  if (!nameInput.value.trim()) {
    alert('Please enter a name for the item');
    return;
  }

  const itemData = {
    name: nameInput.value.trim(),
  };

  if (!valueInput.value || valueInput.value < 1) {
    alert('Please enter a valid initial price (minimum 1 R$)');
    return;
  }
  // RAP validation removed
  if (!stockInput.value || stockInput.value < 1) {
    alert('Please enter a valid stock amount (minimum 1)');
    return;
  }
  itemData.value = parseInt(valueInput.value);
  // RAP assignment removed
  itemData.stock = parseInt(stockInput.value);
  itemData.initialStock = parseInt(stockInput.value);


  const processSubmit = (imageResult) => {
    if (imageResult) {
      itemData.image = imageResult;
    }
    
    if (editingItemId) {
      updateItem(editingItemId, itemData);
    } else {
      releaseItem(itemData);
    }
  };

  if (imagePromise) {
    imagePromise.then(processSubmit).catch(error => alert(error));
  } else {
    // This case happens when editing an item without changing the image
    processSubmit(null);
  }
}

function releaseItem(itemData) {
  const newItem = {
    id: itemIdCounter++,
    name: itemData.name,
    image: itemData.image,
    isCollectible: true,
    createdAt: new Date(),
    value: itemData.value,
    initialPrice: itemData.value, // Store the initial price
    rap: 0, // Set RAP to 0 or remove
    initialStock: itemData.stock,
    available: itemData.stock,
    serialNumbers: Array.from({length: itemData.stock}, (_, i) => i + 1)
  };

  marketplace.unshift(newItem);

  // Give one copy to the admin account
  distributeToRoblox(newItem);
  // Distribute the item to random AIs
  distributeItem(newItem);
  
  updateAllLeaderboards();
  renderMarketplace();
  closeItemPopup();
}

function updateItem(itemId, updates) {
  const itemIndex = marketplace.findIndex(item => item.id === itemId);
  if (itemIndex === -1) return;

  const item = marketplace[itemIndex];
  
  // --- Standard Update Logic ---

  // Update image if a new one was provided
  if (updates.image) {
    item.image = updates.image;
  }

  // Update basic properties
  item.name = updates.name;
  
  const oldValue = item.value;
  item.value = updates.value;
  item.rap = 0; // Set RAP to 0 or remove

  if (oldValue !== item.value) {
      if (!item.stats) { // For items created before this feature
           item.stats = { tradeCount: 0, netPayRatioSum: 0, valueHistory: [{ date: new Date(), value: oldValue }] };
      }
      if(!item.createdAt) item.createdAt = new Date(); // Backfill for old items
      item.stats.valueHistory.push({ date: new Date(), value: item.value });
  }
  
  // Handle stock changes for collectibles
  const stockDiff = updates.initialStock - item.initialStock;
  if (stockDiff > 0) {
    // Increased stock - add new serial numbers
    const newSerials = Array.from({length: stockDiff}, (_, i) => item.initialStock + 1 + i);
    item.serialNumbers.push(...newSerials);
    item.available += stockDiff;

    // Ensure admin has a copy, and determine how many new items to distribute
    const admin = aiUsers.find(ai => ai.isAdmin);
    const adminHadItem = admin.inventory.some(invItem => invItem.item.id === item.id);
    distributeToRoblox(item);
    const itemsToDistribute = adminHadItem ? stockDiff : Math.max(0, stockDiff - 1);

    // Distribute the new copies
    if (itemsToDistribute > 0) {
      distributeItem(item, itemsToDistribute);
    }
  } else if (stockDiff < 0) {
    // Decreased stock - remove from available first
    const decreaseAmount = Math.min(Math.abs(stockDiff), item.available);
    item.available -= decreaseAmount;
    item.serialNumbers.splice(-decreaseAmount, decreaseAmount);
    
    // If we still need to decrease more, remove from inventory
    const remainingDecrease = Math.abs(stockDiff) - decreaseAmount;
    if (remainingDecrease > 0) {
      // Find all instances of this item in AI inventories
      const itemCopies = [];
      aiUsers.forEach(ai => {
        ai.inventory.forEach((invItem, index) => {
          if (invItem.item.id === item.id) {
            itemCopies.push({ ai, index, serial: invItem.serialNumber });
          }
        });
      });
      
      // Sort by serial number (oldest first)
      itemCopies.sort((a, b) => a.serial - b.serial);
      
      // Remove the oldest copies
      for (let i = 0; i < Math.min(remainingDecrease, itemCopies.length); i++) {
        const { ai, index } = itemCopies[i];
        ai.inventory.splice(index, 1);
      }
    }
  }
  item.initialStock = updates.initialStock;
  
  renderMarketplace();
  updateAllLeaderboards();
  closeItemPopup();
}

function distributeToRoblox(item) {
  const admin = aiUsers.find(ai => ai.isAdmin);
  if (!admin) return;

  const hasItem = admin.inventory.some(invItem => invItem.item.id === item.id);

  if (!hasItem && item.available > 0) {
    const serialIndex = item.serialNumbers.length - item.available;
    const serialNumber = item.serialNumbers[serialIndex];
    
    if (serialNumber !== undefined) {
      admin.inventory.push({
        item: item,
        purchaseTime: new Date(),
        serialNumber: serialNumber
      });
      item.available--;
    }
  }
}

function distributeItem(item, quantity = null) {
  const amountToDistribute = quantity !== null ? quantity : item.available;
  if (amountToDistribute <= 0) return;

  // Get weighted list of AIs based on current value, not static class
  const weightedAIs = aiUsers.filter(ai => !ai.isAdmin).map(ai => {
    const value = calculateAIValue(ai);
    let weight = 1000 + value; // Base weight + value

    // Heavily skew weights for valuable items to favor richer players
    if (item.class === 'legendary') {
        weight = Math.pow(weight, 1.5);
    } else if (item.class === 'epic') {
        weight = Math.pow(weight, 1.2);
    } else if (item.class === 'rare') {
        weight = weight * 2;
    }
    
    return { ai, weight };
  });

  // Normalize weights
  const totalWeight = weightedAIs.reduce((sum, { weight }) => sum + weight, 0);
  const normalizedAIs = weightedAIs.map(({ ai, weight }) => ({
    ai,
    probability: weight / totalWeight
  }));

  // Distribute items
  for (let i = 0; i < amountToDistribute; i++) {
    // Select a random AI based on weights
    let random = Math.random();
    let selectedAI = null;
    let cumulativeProb = 0;
    
    for (const { ai, probability } of normalizedAIs) {
      cumulativeProb += probability;
      if (random <= cumulativeProb) {
        selectedAI = ai;
        break;
      }
    }

    if (!selectedAI) {
      // Fallback to random selection if something went wrong
      const regularUsers = aiUsers.filter(u => !u.isAdmin);
      if (regularUsers.length > 0) {
        selectedAI = regularUsers[Math.floor(Math.random() * regularUsers.length)];
      }
    }

    if (!selectedAI) continue; // Skip if no user could be selected

    // Get the next available serial number
    const serialIndex = item.serialNumbers.length - item.available;
    const serialNumber = item.serialNumbers[serialIndex];

    // Add to AI's inventory
    if (serialNumber !== undefined) {
      selectedAI.inventory.push({
        item: item,
        purchaseTime: new Date(),
        serialNumber: serialNumber
      });
      item.available--;
    }
  }

  renderMarketplace();
  updateAllLeaderboards();
}

// Marketplace Rendering
function renderMarketplace() {
  itemList.innerHTML = '';
  
  const searchInput = document.getElementById('marketplace-search-input');
  const filter = searchInput ? searchInput.value.trim().toLowerCase() : '';
  
  const filteredMarketplace = filter 
    ? marketplace.filter(item => item.name.toLowerCase().includes(filter))
    : marketplace;

  if (filteredMarketplace.length === 0) {
    const emptyMessage = filter 
      ? "No items found matching your search." 
      : "No items available in the marketplace yet.";
    itemList.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--gray-light);">${emptyMessage}</p>`;
    return;
  }
  
  filteredMarketplace.forEach(item => {
    const itemCard = document.createElement('div');
    itemCard.className = 'item-card';
    
    const stockPercentage = (item.available / item.initialStock) * 100;
    const distributed = item.initialStock - item.available;
    
    itemCard.innerHTML = `
      <img src="${item.image}" alt="${item.name}" class="item-image">
      <div class="item-details">
        <div class="item-name">${item.name}</div>
        <div class="item-value">Value: R$ ${item.value.toLocaleString()} ${getValuationStatusIcon(item)}</div>
        <div class="item-rap" style="display:none;">RAP: R$ ${item.rap.toLocaleString()}</div>
        <div class="item-stock">
          Stock: ${item.available}/${item.initialStock}
          <div class="stock-bar">
            <div class="stock-fill" style="width: ${stockPercentage}%"></div>
          </div>
        </div>
        <div class="item-owners">Distributed: ${distributed}</div>
        <div class="item-actions">
          <button class="btn btn-secondary" onclick="openItemPopup(${JSON.stringify(item).replace(/"/g, '&quot;')})">Edit</button>
          <button class="btn" onclick="openItemStatsPopup(${item.id})">View</button>
        </div>
      </div>
      <div class="item-status">Collectible</div>
    `;
    
    itemList.appendChild(itemCard);
  });
}

// Leaderboard Rendering
function renderLeaderboard(searchTerm = '') {
  leaderboardList.innerHTML = '';
  
  let userList;
  switch(leaderboardType) {
    case 'value': userList = valueLeaderboard; break;
    case 'rap': userList = rapLeaderboard; break;
    case 'items': userList = itemsLeaderboard; break;
    default: userList = [];
  }

  const filteredUsers = searchTerm
    ? userList.filter(user => user.name.toLowerCase().includes(searchTerm.toLowerCase()))
    : userList;
  
  filteredUsers.slice(0, 5000).forEach((user, index) => {
    // Find the user's actual rank from the unfiltered list
    const actualRank = userList.findIndex(u => u.id === user.id) + 1;
    
    const row = document.createElement('tr');
    row.onclick = () => openAIPopup(user);
    
    let valueDisplay;
    switch(leaderboardType) {
      case 'value':
        valueDisplay = `R$ ${Math.floor(calculateAIValue(user)).toLocaleString()}`;
        break;
      case 'rap':
        valueDisplay = `R$ ${Math.floor(calculateAIRAP(user)).toLocaleString()}`;
        break;
      case 'items':
        valueDisplay = user.inventory.length;
        break;
    }
    
    row.innerHTML = `
      <td class="leaderboard-rank">${actualRank}</td>
      <td class="leaderboard-name">${user.name}</td>
      <td class="${leaderboardType === 'value' ? 'leaderboard-value' : leaderboardType === 'rap' ? 'leaderboard-rap' : ''}">${valueDisplay}</td>
      <td>${user.inventory.length}</td>
    `;
    
    leaderboardList.appendChild(row);
  });
}

function calculateAIValue(ai) {
  let inventoryValue = 0;
  ai.inventory.forEach(item => {
    inventoryValue += item.item.value;
  });
  return inventoryValue;
}

function calculateAIRAP(ai) {
  return 0; // RAP is removed.
}

// AI Generation
function generateAIUsers(count) {
    const prefixes = ["TheReal", "Its", "Official", "Just", "Mr", "Mrs", "Dr", "Xx"];
    const suffixes = ["YT", "TV", "Pro", "HD", "Dev", "RBX", "Plays", "Lover", "Fan", "God", "King", "Queen", "Slayer"];
    const words = [
        // Nouns
        "Gamer", "Builder", "Cat", "Dog", "Panda", "Dragon", "Knight", "Player", "Master", "Dude", "Girl", "Boy", "Warrior",
        "Legend", "Hunter", "Pilot", "Scout", "Wizard", "Titan", "Spectre", "Shadow", "Robo", "Cyber", "Ninja", "King", "Queen",
        "Agent", "Reaper", "Ghost", "Wolf", "Fox", "Lion", "Tiger", "Shark", "Phoenix", "Demon", "Angel", "Star", "Comet", "Galaxy",
        // Adjectives
        "Super", "Cool", "Awesome", "Epic", "Happy", "Lazy", "Pro", "Noob", "Silent", "Frosty", "Aqua", "Blaze", "Galactic", "Cosmic",
        "Red", "Blue", "Green", "Golden", "Dark", "Light", "Ancient", "Future", "Crazy", "Silly", "Serious", "Funny", "Hyper",
        // Verbs
        "Mining", "Building", "Fighting", "Playing", "Exploring", "Racing", "Flying", "Jumping"
    ];

    const users = [];
    const generatedNames = new Set();

    const randomChoice = (arr) => arr[Math.floor(Math.random() * arr.length)];
    const randomNum = (max) => Math.floor(Math.random() * max);

    while (users.length < count) {
        let name;
        const patternType = Math.random();

        if (patternType < 0.25) { // 25% chance: WordWord#### (e.g., ShadowGamer1234)
            name = `${randomChoice(words)}${randomChoice(words)}${randomNum(9999) + 1}`;
        } else if (patternType < 0.45) { // 20% chance: Prefix_Word_Suffix (e.g., TheReal_Dragon_YT)
            name = `${randomChoice(prefixes)}_${randomChoice(words)}_${randomChoice(suffixes)}`;
        } else if (patternType < 0.60) { // 15% chance: Word####Suffix (e.g., Player1234Pro)
            name = `${randomChoice(words)}${randomNum(5000)}${randomChoice(suffixes)}`;
        } else if (patternType < 0.75) { // 15% chance: xXWordWordXx (e.g., xXWarriorLegendXx)
            name = `xX${randomChoice(words)}${randomChoice(words)}Xx`;
        } else if (patternType < 0.90) { // 15% chance: Word_Word_#### (e.g., Epic_Builder_2010)
            name = `${randomChoice(words)}_${randomChoice(words)}_${1000 + randomNum(9012)}`;
        } else { // 10% chance: PrefixWord####
            name = `${randomChoice(prefixes)}${randomChoice(words)}${randomNum(1000)}`;
        }

        // Ensure name is within a reasonable length
        if (name.length > 20) {
            name = name.substring(0, 20);
        }
        
        if (name.length < 3) {
            name = `${name}${randomNum(100)}`; // Pad very short names
        }

        if (!generatedNames.has(name)) {
            generatedNames.add(name);
            users.push({
                id: users.length + 1,
                name: name,
                inventory: [],
                valueHistory: [],
                rapHistory: [],
                economicClass: Math.random()
            });
        }
    }
  
  return users;
}

function toggleImageSource(source) {
    const uploadGroup = document.getElementById('image-upload-group');
    const urlGroup = document.getElementById('image-url-group');
    if (source === 'upload') {
        uploadGroup.style.display = 'block';
        urlGroup.style.display = 'none';
    } else { // url
        uploadGroup.style.display = 'none';
        urlGroup.style.display = 'block';
    }
}

function updateAllLeaderboards() {
    valueLeaderboard = [...aiUsers].sort((a, b) => calculateAIValue(b) - calculateAIValue(a));
    rapLeaderboard = [...aiUsers].sort((a, b) => calculateAIRAP(b) - calculateAIRAP(a));
    itemsLeaderboard = [...aiUsers].sort((a, b) => b.inventory.length - a.inventory.length);
    renderLeaderboard(document.getElementById('leaderboard-search-input').value);
}

// --- Start of new/modified code: Report System ---

const REPORT_REASONS = [
    "Suspicious trading activity (scamming)",
    "Use of exploits to gain items",
    "Account Theft (phishing)",
    "Black market item purchases",
    "Automated bot-like behavior",
    "Stolen Items",
    "High-Value Trade Review"
];

let currentReportContext = null;

function generateRandomReport() {
    const regularUsers = aiUsers.filter(u => !u.isAdmin);
    if (regularUsers.length < 2) return;

    let reason = REPORT_REASONS[Math.floor(Math.random() * REPORT_REASONS.length)];

    // Ensure there's a valuable enough player to be a victim for theft reports
    const potentialVictims = valueLeaderboard.slice(0, Math.ceil(valueLeaderboard.length * 0.2)).filter(u => u.inventory.length > 0);
    if (reason === "Stolen Items" && potentialVictims.length === 0) {
        // Can't generate a theft report, fallback to a different reason
        reason = "Automated bot-like behavior";
    }

    let userToReport;
    let reportContext = null;

    if (reason === "Stolen Items") {
        const victim = potentialVictims[Math.floor(Math.random() * potentialVictims.length)];
        const thiefPool = regularUsers.filter(u => u.id !== victim.id);
        const thief = thiefPool[Math.floor(Math.random() * thiefPool.length)];
        
        // Steal the victim's most valuable item
        const stolenItem = victim.inventory.sort((a,b) => b.item.value - a.item.value)[0];
        
        // Remove from victim
        const victimItemIndex = victim.inventory.findIndex(i => i.item.id === stolenItem.item.id && i.serialNumber === stolenItem.serialNumber);
        if (victimItemIndex > -1) {
            victim.inventory.splice(victimItemIndex, 1);
        }

        // Give to thief
        thief.inventory.push(stolenItem);
        userToReport = thief;

        reportContext = {
            type: 'theft',
            victim: victim,
            item: stolenItem
        };

    } else {
        userToReport = regularUsers[Math.floor(Math.random() * regularUsers.length)];
    }

    const newReport = {
        id: reportIdCounter++,
        user: userToReport,
        reason: reason,
        timestamp: new Date(),
        isUnread: true,
        context: reportContext,
    };

    reports.unshift(newReport);
    reportIndicator.classList.add('active');
    
    // Only render if the tab is active, otherwise the unread status will be cleared
    if(document.getElementById('reports').classList.contains('active')) {
      renderReports();
    }
}

function renderReports() {
    reportList.innerHTML = '';

    if (reports.length === 0) {
        reportList.innerHTML = '<p style="text-align: center; padding: 40px; color: var(--text-secondary);">No active reports.</p>';
        return;
    }

    reports.forEach(report => {
        const reportCard = document.createElement('div');
        reportCard.className = 'report-card';
        if (report.isUnread) {
            reportCard.classList.add('unread');
        }
        reportCard.onclick = () => {
            currentReportContext = report;
            openAIPopup(report.user);
            report.isUnread = false;
            reportCard.classList.remove('unread');
        };

        const timeString = report.timestamp.toLocaleTimeString();
        let reasonHtml = `Reason: ${report.reason}`;
        if (report.context && report.context.type === 'theft') {
            reasonHtml = `Reason: Stolen Items <br><small>(Stole <strong>${report.context.item.item.name} #${report.context.item.serialNumber}</strong> from ${report.context.victim.name})</small>`;
        }


        reportCard.innerHTML = `
            <div class="report-header">
                <span class="report-user">${report.user.name}</span>
                <span class="report-time">${timeString}</span>
            </div>
            <p class="report-reason">${reasonHtml}</p>
        `;
        reportList.appendChild(reportCard);
    });
}

function startReportTimer() {
    const generateAndSchedule = () => {
        generateRandomReport();
        // Schedule next report in 1-5 minutes
        const nextReportTime = (Math.random() * 4 * 60 * 1000) + (1 * 60 * 1000);
        setTimeout(generateAndSchedule, nextReportTime);
    };
    generateAndSchedule();
}

function handleTheftBan(returnItemToVictim) {
    if (!currentViewingAI || !currentReportContext) return;

    const thief = currentViewingAI;
    const { victim, item: stolenItem } = currentReportContext.context;
    
    // 1. Isolate the stolen item from the thief's inventory
    const stolenItemIndex = thief.inventory.findIndex(i => i.item.id === stolenItem.item.id && i.serialNumber === stolenItem.serialNumber);
    if (stolenItemIndex > -1) {
        thief.inventory.splice(stolenItemIndex, 1);
    }
    
    // 2. Ban the thief (this transfers their remaining items to admin)
    banAI(thief);

    // 3. Handle the stolen item
    if (returnItemToVictim) {
        victim.inventory.push(stolenItem);
        alert(`Stolen item ${stolenItem.item.name} has been returned to ${victim.name}.`);
    } else {
        const admin = aiUsers.find(ai => ai.isAdmin);
        if (admin) {
            admin.inventory.push(stolenItem);
            alert(`Stolen item ${stolenItem.item.name} has been confiscated by ${admin.name}.`);
        }
    }

    // 4. Clean up the report
    const reportIndex = reports.findIndex(r => r.id === currentReportContext.id);
    if (reportIndex > -1) {
        reports.splice(reportIndex, 1);
    }
    
    // This will have been called by banAI, but we call again to reflect item return
    updateAllLeaderboards(); 
}

// --- End of Report System code ---

// --- Start of Trading System ---

let lastTradeTimestamp = new Date();

function getStockMultiplier(item) {
    const stock = item.initialStock;
    if (stock <= 50) return 1.5;
    if (stock <= 250) return 1.25;
    if (stock <= 1000) return 1.1;
    return 1.0;
}

function attemptTopTierTrade() {
    // Select from top 100 who have items to trade
    const top100Pool = valueLeaderboard.slice(0, 100).filter(u => !u.isAdmin && u.inventory.length > 0);

    if (top100Pool.length < 2) {
        // Not enough rich players, fall back to a high-value trade
        attemptHighValueTrade();
        return;
    }

    // Weighted pick among the top players
    const totalValue = top100Pool.reduce((sum, u) => sum + calculateAIValue(u), 0);
    function weightedPick(pool) {
        if (!pool || pool.length === 0) return null;
        let r = Math.random() * totalValue;
        for (const u of pool) {
            r -= calculateAIValue(u);
            if (r <= 0) return u;
        }
        return pool[pool.length - 1];
    }

    const traderA = weightedPick(top100Pool);
    const traderBPool = top100Pool.filter(u => u.id !== traderA.id);
    if (traderBPool.length === 0) {
         attemptHighValueTrade(); // Fallback if we can't get a second trader
         return;
    }
    const traderB = weightedPick(traderBPool);

    if (traderA && traderB) {
        negotiateAndExecuteTrade(traderA, traderB);
    } else {
        attemptHighValueTrade(); // Fallback
    }
}

function attemptRandomTrade(isForced = false) {
    if (aiUsers.length < 2) return;

    // Richer users are more likely to initiate trades
    const traderPool = aiUsers.filter(u => !u.isAdmin && u.inventory.length > 0);
    if (traderPool.length < 2) return;
    
    const totalValue = traderPool.reduce((sum, u) => sum + Math.max(1000, calculateAIValue(u)), 0);
    const pickInitiator = () => {
        let random = Math.random() * totalValue;
        for (const user of traderPool) {
            random -= Math.max(1000, calculateAIValue(user));
            if (random <= 0) return user;
        }
        return traderPool[traderPool.length - 1];
    };

    const initiator = pickInitiator();
    const partnerPool = traderPool.filter(u => u.id !== initiator.id);
    if (partnerPool.length === 0) return;
    const partner = partnerPool[Math.floor(Math.random() * partnerPool.length)];

    negotiateAndExecuteTrade(initiator, partner, isForced);
}

function negotiateAndExecuteTrade(initiator, partner, isForced = false) {
    // --- Phase 1: Initiator Decides What They Want (Shopping List) ---
    const partnerInventory = [...partner.inventory].sort((a,b) => getPerceivedValue(b.item) - getPerceivedValue(a.item));
    let shoppingList = []; // The items the initiator wants from the partner
    let shoppingListValue = 0;

    // The initiator might want one big item or a few smaller ones.
    const decision = Math.random();
    if (decision < 0.7 && partnerInventory.length > 0) { // 70% chance to go for one big item
        shoppingList.push(partnerInventory[0]);
    } else { // 30% chance to go for a bundle of smaller/medium items
        const initiatorValue = calculateAIValue(initiator);
        const affordableItems = partnerInventory.filter(i => getPerceivedValue(i.item) < initiatorValue * 0.6);
        affordableItems.sort(() => 0.5 - Math.random()); // Shuffle to get variety
        for(const item of affordableItems) {
            if (shoppingList.length >= 3) break; // Don't ask for too much at once
            if (shoppingListValue + getPerceivedValue(item.item) < initiatorValue * 0.8) {
                shoppingList.push(item);
                shoppingListValue += getPerceivedValue(item.item);
            }
        }
    }
    
    if (shoppingList.length === 0) return false;

    // --- Phase 2: Building the Deal ---
    let initiatorOffer = [];
    let partnerOffer = shoppingList; // Partner's side starts with the target items
    
    const initiatorTradableItems = initiator.inventory
        .filter(i => !shoppingList.some(s => s.item.id === i.item.id))
        .sort((a,b) => getPerceivedValue(a.item) - getPerceivedValue(b.item));

    let initiatorValue = 0;
    let partnerValue = partnerOffer.reduce((sum, i) => sum + getPerceivedValue(i.item), 0);

    // Initiator builds an offer to match the partner's perceived value
    for (const item of initiatorTradableItems) {
        if (initiatorOffer.length >= 5) break;
        if (initiatorValue >= partnerValue * 1.05) break; // Aim for a slight overpay
        
        initiatorOffer.push(item);
        initiatorValue += getPerceivedValue(item.item);
    }

    if (initiatorOffer.length === 0) return false;

    // --- Phase 3: Final Evaluation & Balancing ---
    // This is a simplified final check. A real negotiation would be a loop.
    const finalRatio = initiatorValue / partnerValue;
    
    let acceptanceChance = 0;
    if (finalRatio < 0.98) acceptanceChance = 0.1;  // Unlikely to accept underpay
    else if (finalRatio < 1.2) acceptanceChance = 0.8; // Very likely to accept fair/slight OP
    else acceptanceChance = 0.4; // Less likely to accept a huge OP

    if (isForced) acceptanceChance = 1.0;
    
    // The partner has a small chance to "get greedy" and ask for one more small item if the offer is good
    if (Math.random() < 0.2 && finalRatio > 1.1 && initiatorTradableItems.length > initiatorOffer.length) {
        const smallestAvailableItem = initiatorTradableItems.find(i => !initiatorOffer.some(o => o.serialNumber === i.serialNumber));
        if (smallestAvailableItem && initiatorOffer.length < 5) {
            initiatorOffer.push(smallestAvailableItem);
        }
    }

    if (Math.random() < acceptanceChance) {
        executeTrade(initiator, partner, initiatorOffer, partnerOffer);
        return true;
    }

    return false;
}

function executeTrade(traderA, traderB, itemsFromA, itemsFromB) {
    lastTradeTimestamp = new Date(); // Update the timestamp
    const valueFromA = itemsFromA.reduce((sum, i) => sum + i.item.value, 0);
    const valueFromB = itemsFromB.reduce((sum, i) => sum + i.item.value, 0);

    const allTradedItems = [...itemsFromA, ...itemsFromB];
    for (const invItem of allTradedItems) {
         if (!invItem.item.stats) { // Initialize if not present for old data
             invItem.item.stats = { tradeCount: 0, netPayRatioSum: 0, valueHistory: [{ date: new Date(), value: invItem.item.value }] };
         }
         invItem.item.stats.tradeCount++;
    }

    // Calculate pay ratios and update stats
    if (valueFromB > 0) {
        const ratioForA = valueFromA / valueFromB; // How much A gave vs what B gave
        itemsFromB.forEach(invItem => { // Items B gave away
             invItem.item.stats.netPayRatioSum += (ratioForA - 1);
        });
    }
    if (valueFromA > 0) {
        const ratioForB = valueFromB / valueFromA; // How much B gave vs what A gave
        itemsFromA.forEach(invItem => { // Items A gave away
            invItem.item.stats.netPayRatioSum += (ratioForB - 1);
        });
    }
    
    // Remove items from A, add to B
    for(const item of itemsFromA) {
        const index = traderA.inventory.findIndex(i => i.item.id === item.item.id && i.serialNumber === item.serialNumber);
        if(index > -1) {
            traderA.inventory.splice(index, 1);
            traderB.inventory.push(item);
        }
    }

    // Remove items from B, add to A
    for(const item of itemsFromB) {
        const index = traderB.inventory.findIndex(i => i.item.id === item.item.id && i.serialNumber === item.serialNumber);
        if(index > -1) {
            traderB.inventory.splice(index, 1);
            traderA.inventory.push(item);
        }
    }

    const trade = { traderA, traderB, itemsFromA, itemsFromB, timestamp: new Date() };
    tradeHistory.unshift(trade);
    if (tradeHistory.length > 100) tradeHistory.pop(); // Keep history capped

    // Update value based on trade performance for all involved items
    allTradedItems.forEach(invItem => updateItemValueFromTrades(invItem.item));
    
    // Check for high-value trade alert
    if (allTradedItems.some(i => i.item.value >= 500000)) {
        generateTradeAlertReport(trade);
    }
    
    updateAllLeaderboards();
    if(document.getElementById('trades').classList.contains('active')) {
      renderTradeHistory();
    }
}

function generateTradeAlertReport(trade) {
    const newReport = {
        id: reportIdCounter++,
        user: trade.traderA, // Arbitrarily assign one user to the report card
        reason: "High-Value Trade Review",
        timestamp: new Date(),
        isUnread: true,
        context: {
            type: 'trade',
            trade: trade
        }
    };
    reports.unshift(newReport);
    reportIndicator.classList.add('active');
}

function renderTradeHistory() {
    tradeHistoryList.innerHTML = '';
    const tradeSearchInput = document.getElementById('trade-history-search');
    const filter = tradeSearchInput ? tradeSearchInput.value.trim().toLowerCase() : '';
    const filteredTrades = filter ? tradeHistory.filter(trade => {
        if (trade.traderA.name.toLowerCase().includes(filter) || trade.traderB.name.toLowerCase().includes(filter)) return true;
        // Check items from both sides
        const itemsA = trade.itemsFromA.some(i => i.item.name.toLowerCase().includes(filter));
        const itemsB = trade.itemsFromB.some(i => i.item.name.toLowerCase().includes(filter));
        return itemsA || itemsB;
    }) : tradeHistory;
    if (filteredTrades.length === 0) {
        tradeHistoryList.innerHTML = '<p style="text-align: center; padding: 40px; color: var(--text-secondary);">No trades have occurred yet.</p>';
        return;
    }
    filteredTrades.forEach(trade => {
        const tradeCard = document.createElement('div');
        tradeCard.className = 'trade-card';
        const valueFromA = trade.itemsFromA.reduce((sum, item) => sum + item.item.value, 0);
        const valueFromB = trade.itemsFromB.reduce((sum, item) => sum + item.item.value, 0);
        const itemsFromA_HTML = trade.itemsFromA.map(i => `<div class=\"trade-item\"><img src=\"${i.item.image}\"> ${i.item.name} (#${i.serialNumber})<span class=\"leaderboard-value\" style=\"margin-left: auto;\">R$ ${i.item.value.toLocaleString()}</span></div>`).join('');
        const itemsFromB_HTML = trade.itemsFromB.map(i => `<div class=\"trade-item\"><img src=\"${i.item.image}\"> ${i.item.name} (#${i.serialNumber})<span class=\"leaderboard-value\" style=\"margin-left: auto;\">R$ ${i.item.value.toLocaleString()}</span></div>`).join('');
        tradeCard.innerHTML = `
            <div class=\"trade-side\">\n                <div class=\"trade-card-header\">\n                    <span class=\"trade-card-user\">${trade.traderA.name}</span>\n                </div>\n                <div class=\"trade-items\">${itemsFromA_HTML}</div>\n                <div class=\"trade-total leaderboard-value\">Total: R$ ${valueFromA.toLocaleString()}</div>\n            </div>\n            <div style=\"font-size: 24px;\">&#x21C4;</div>\n            <div class=\"trade-side\">\n                <div class=\"trade-card-header\">\n                     <span class=\"trade-card-user\">${trade.traderB.name}</span>\n                </div>\n                <div class=\"trade-items\">${itemsFromB_HTML}</div>\n                <div class=\"trade-total leaderboard-value\">Total: R$ ${valueFromB.toLocaleString()}</div>\n            </div>\n        `;
        tradeHistoryList.appendChild(tradeCard);
    });
}

function startTradingTimer() {
    setInterval(() => {
        // Attempt to run 3 trades every 10 seconds.
        for (let i = 0; i < 3; i++) {
            // Use a slight delay between each attempt within the batch
            setTimeout(attemptRandomTrade, i * 100);
        }
    }, 10000);

    // Also keep the inactivity check to force trades if the market is stale.
    setInterval(() => {
        if (new Date() - lastTradeTimestamp > 30000) {
            console.log("Forcing a trade due to inactivity...");
            attemptRandomTrade(true); // The 'true' flag makes the AIs highly likely to accept
        }
    }, 15000);
}

// --- End of Trading System ---

// --- Admin Panel ---
function renderAdminPanel() {
    adminItemSelect.innerHTML = '';
    // Sort items alphabetically for easier selection
    const sortedMarketplace = [...marketplace].sort((a,b) => a.name.localeCompare(b.name));
    
    sortedMarketplace.forEach(item => {
        const option = document.createElement('option');
        option.value = item.id;
        option.textContent = `${item.name} (${item.isCollectible ? `Value: ${item.value.toLocaleString()}` : `Price: ${item.price.toLocaleString()}`})`;
        adminItemSelect.appendChild(option);
    });
}

function adminGiveItem() {
    const userIdInput = document.getElementById('admin-user-id');
    const userId = parseInt(userIdInput.value);
    const itemId = parseInt(adminItemSelect.value);

    if (isNaN(userId)) {
        alert("Please enter a valid User ID.");
        return;
    }
    if (isNaN(itemId)) {
        alert("Please select an item.");
        return;
    }

    const targetUser = aiUsers.find(u => u.id === userId) || bannedUsers.find(u => u.id === userId);
    const itemTemplate = marketplace.find(i => i.id === itemId);

    if (!targetUser) {
        alert(`User with ID ${userId} not found.`);
        return;
    }
    if (!itemTemplate) {
        alert("Item template not found. This should not happen.");
        return;
    }

    // This is a new, spawned item. It gets a new serial number.
    const newSerialNumber = itemTemplate.initialStock + 1;
    itemTemplate.initialStock++;
    itemTemplate.serialNumbers.push(newSerialNumber);
    // Note: We don't increment `available` because this is a direct grant, not new stock for distribution.

    const newItem = {
        item: itemTemplate,
        purchaseTime: new Date(),
        serialNumber: newSerialNumber
    };
    
    // For non-collectibles given by admin, we also need to track ownership
    if (!itemTemplate.isCollectible) {
        if(!itemTemplate.owners) itemTemplate.owners = 0;
        itemTemplate.owners++;
    }

    const inventory = targetUser.isBanned ? targetUser.bannedInventory : targetUser.inventory;
    inventory.push(newItem);

    userIdInput.value = '';
    alert(`Successfully gave "${itemTemplate.name}" to ${targetUser.name} (ID: ${targetUser.id}).`);
    updateAllLeaderboards();
    updateAIHistoryOnChange();
}

// Initialize
renderMarketplace();
updateAllLeaderboards();
startReportTimer();
startTradingTimer();
renderBanLand();

document.getElementById('leaderboard-search-input').addEventListener('input', (e) => {
    renderLeaderboard(e.target.value);
});
document.getElementById('marketplace-search-input').addEventListener('input', renderMarketplace);

// --- Settings ---
function exportData() {
    try {
        const dataToSave = {
            marketplace: marketplace,
            aiUsers: aiUsers,
            bannedUsers: bannedUsers,
            reports: reports,
            tradeHistory: tradeHistory,
            itemIdCounter: itemIdCounter,
            reportIdCounter: reportIdCounter,
        };

        // Instead of stringifying the whole object, we stringify parts
        // and create a Blob. This is much more memory-friendly for large datasets.
        const parts = [
            '{',
            `"marketplace": ${JSON.stringify(dataToSave.marketplace)},`,
            `"aiUsers": ${JSON.stringify(dataToSave.aiUsers)},`,
            `"bannedUsers": ${JSON.stringify(dataToSave.bannedUsers)},`,
            `"reports": ${JSON.stringify(dataToSave.reports)},`,
            `"tradeHistory": ${JSON.stringify(dataToSave.tradeHistory)},`,
            `"itemIdCounter": ${JSON.stringify(dataToSave.itemIdCounter)},`,
            `"reportIdCounter": ${JSON.stringify(dataToSave.reportIdCounter)}`,
            '}'
        ];

        const blob = new Blob(parts, { type: "application/json" });
        const url = URL.createObjectURL(blob);
        
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", url);
        downloadAnchorNode.setAttribute("download", `roblox_sim_data_${new Date().toISOString()}.json`);
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();

        // Clean up the object URL
        URL.revokeObjectURL(url);

        alert("Data has been exported successfully.");

    } catch(error) {
        alert("An error occurred during export. The dataset might be too large. Error: " + error.message);
    }
}

function importData(event) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }

    const reader = new FileReader();
    reader.onload = function(e) {
        // Yield to the browser to prevent UI freezing on large file loads
        setTimeout(() => {
            try {
                const data = JSON.parse(e.target.result);
                
                // Basic validation
                if (!data.aiUsers || !data.marketplace || !data.bannedUsers) {
                    throw new Error("Invalid data file. Missing critical information.");
                }

                // Load data
                // Clear existing state first
                marketplace.length = 0;
                aiUsers.length = 0;
                bannedUsers.length = 0;
                reports.length = 0;
                tradeHistory.length = 0;

                // Push new state
                marketplace.push(...data.marketplace);
                aiUsers.push(...data.aiUsers);
                
                // Rehydrate date strings from the imported file back into Date objects
                if (data.bannedUsers) {
                    data.bannedUsers.forEach(user => user.banDate = new Date(user.banDate));
                    bannedUsers.push(...data.bannedUsers);
                }
                if (data.reports) {
                    data.reports.forEach(report => report.timestamp = new Date(report.timestamp));
                    reports.push(...data.reports);
                }
                if (data.tradeHistory) {
                    data.tradeHistory.forEach(trade => trade.timestamp = new Date(trade.timestamp));
                    tradeHistory.push(...data.tradeHistory);
                }

                itemIdCounter = data.itemIdCounter || itemIdCounter;
                reportIdCounter = data.reportIdCounter || reportIdCounter;
                
                // Re-render everything
                updateAllLeaderboards();
                renderMarketplace();
                renderReports();
                renderBanLand();
                renderTradeHistory();
                renderAdminPanel();

                // Switch to a default tab
                switchTab('marketplace');
                
                alert("Data imported successfully!");

            } catch (error) {
                alert("Failed to import data. File may be corrupt or invalid. Error: " + error.message);
            } finally {
                // Reset file input so the same file can be loaded again
                event.target.value = '';
            }
        }, 100);
    };
    reader.readAsText(file);
}

function goCollectible(itemId, value, rap) {
    const itemIndex = marketplace.findIndex(item => item.id === itemId);
    if (itemIndex === -1) return;
    const item = marketplace[itemIndex];

    if (!item || item.isCollectible) return;

    // --- This is the "going limited" event ---
    item.isCollectible = true;
    // Base value on price, with a small bonus for hype
    item.value = value || Math.ceil(item.price * (1.2 + Math.random() * 0.3)); 
    item.rap = rap || Math.ceil(item.price * (1.1 + Math.random() * 0.2)); 
    
    const owners = [];
    
    const findOwnersIn = (userList) => {
        userList.forEach(user => {
            const inventory = user.isBanned ? user.bannedInventory : user.inventory;
            if(!inventory) return;

            inventory.forEach((invItem, index) => {
                if (invItem.item.id === itemId && !invItem.serialNumber) {
                    owners.push({ai: user, purchaseIndex: index});
                }
            });
        });
    }

    findOwnersIn(aiUsers);
    findOwnersIn(bannedUsers);
      
    item.initialStock = owners.length;
    item.available = 0; // All copies are now owned
    item.serialNumbers = Array.from({length: owners.length}, (_, i) => i + 1);
    
    // Convert purchases to official owned items with serials
    owners.forEach(({ai, purchaseIndex}, serialIndex) => {
        const inventory = ai.isBanned ? ai.bannedInventory : ai.inventory;
        if(inventory[purchaseIndex]) {
            inventory[purchaseIndex].serialNumber = serialIndex + 1;
        }
    });

    // Clean up old properties
    delete item.price;
    delete item.owners;
    delete item.offSaleDate;
      
    alert(`${item.name} has gone collectible! ${owners.length} owners now have a limited version.`);
    
    updateAllLeaderboards();
    renderMarketplace();
}

// --- Item Stats ---
function openItemStatsPopup(itemId) {
    const item = marketplace.find(i => i.id === itemId);
    if (!item) return;
    
    if (!item.stats) {
        item.stats = { tradeCount: 0, netPayRatioSum: 0, valueHistory: [{ date: new Date(), value: item.value }] };
    }

    document.getElementById('item-stats-title').textContent = `${item.name} - Stats`;
    document.getElementById('item-stats-img-src').src = item.image;
    document.getElementById('item-stats-img-src').alt = item.name;

    document.getElementById('item-stats-demand').textContent = calculateDemand(item);
    const avgOp = item.stats.tradeCount > 0 ? (item.stats.netPayRatioSum / item.stats.tradeCount) * 100 : 0;
    document.getElementById('item-stats-op').textContent = `${avgOp.toFixed(1)}%`;
    document.getElementById('item-stats-trades').textContent = item.stats.tradeCount;

    renderValueChart(item);
    itemStatsPopup.classList.add('active');
}

function closeItemStatsPopup() {
    itemStatsPopup.classList.remove('active');
    if (valueChartInstance) {
        valueChartInstance.destroy();
    }
}

function calculateDemand(item) {
    if (!item.stats || item.stats.tradeCount < 5) {
        return "N/A"; // Not enough data
    }
    
    const avgPayRatio = item.stats.netPayRatioSum / item.stats.tradeCount;

    if (avgPayRatio > 0.10) return "Very High"; // Consistently gets >10% overpay
    if (avgPayRatio > 0.04) return "High";      // Consistently gets >4% overpay
    if (avgPayRatio > -0.04) return "Medium";   // Trades around value (-4% to 4%)
    if (avgPayRatio > -0.10) return "Low";      // Consistently gets <4% underpay
    return "Very Low"; // Consistently gets >10% underpay
}

function getValuationStatusIcon(item) {
    if (!item.stats || item.stats.tradeCount < 10) {
        return `<span title="Value is based on initial price. Market value will be determined after more trades." style="cursor: help; color: var(--gray-mid-light);">âš™ï¸</span>`;
    }
    const trend = calculateItemTrend(item);
    if (trend > 1.05) return `<span title="Value is trending up." style="color: var(--success-green);">ðŸ“ˆ</span>`;
    if (trend < 0.95) return `<span title="Value is trending down." style="color: var(--danger-red);">ðŸ“‰</span>`;
    return `<span title="Value is stable." style="color: var(--gray-light);">=</span>`;
}

function updateItemValueFromTrades(item) {
    if (!item.stats || item.stats.tradeCount < 10) {
        return; // Not enough data to adjust value yet
    }
    
    // Calculate the average over/underpay percentage for this item
    const avgPayRatio = item.stats.netPayRatioSum / item.stats.tradeCount;
    
    // Define an adjustment factor to prevent wild swings.
    // A smaller factor makes the value more stable.
    const adjustmentFactor = 0.05; 
    
    const change = item.value * avgPayRatio * adjustmentFactor;
    
    // New value must not fall below a certain threshold of its initial price, e.g., 25%
    const floorValue = item.initialPrice * 0.25;
    
    let newValue = Math.max(floorValue, item.value + change);
    
    if (newValue !== item.value) {
        item.value = Math.round(newValue);
        
        // After a value update, we should dampen the netPayRatioSum to prevent
        // old trades from having a perpetual effect on the new value.
        item.stats.netPayRatioSum *= 0.8; 

        // Add to value history
        item.stats.valueHistory.push({ date: new Date(), value: item.value });
        if (item.stats.valueHistory.length > 100) item.stats.valueHistory.shift();
    }
}

function renderValueChart(item) {
    const ctx = document.getElementById('value-history-chart').getContext('2d');
    
    if (valueChartInstance) {
        valueChartInstance.destroy();
    }

    const history = item.stats.valueHistory.sort((a,b) => new Date(a.date) - new Date(b.date));
    const labels = history.map(entry => new Date(entry.date).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}));
    const data = history.map(entry => entry.value);

    valueChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'Item Value (R$)',
                data: data,
                borderColor: 'white',
                backgroundColor: 'rgba(255, 255, 255, 0.1)',
                fill: true,
                tension: 0.1,
                pointRadius: 4,
                pointBackgroundColor: 'white'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                tooltip: {
                    titleColor: 'white',
                    bodyColor: 'white',
                    callbacks: {
                        label: function(context) {
                            return `Value: R$ ${context.parsed.y.toLocaleString()}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: false,
                    ticks: { color: 'white' },
                     grid: { color: 'rgba(255, 255, 255, 0.2)' }
                },
                x: {
                    ticks: { color: 'white' },
                     grid: { display: false }
                }
            }
        }
    });
}

// Attach search event for trade history
document.getElementById('trade-history-search').addEventListener('input', () => renderTradeHistory());

// --- AI Value/RAP History Tracking ---
function ensureAIHistory(ai) {
  if (!ai.valueHistory) ai.valueHistory = [];
  if (!ai.rapHistory) ai.rapHistory = [];
}

function recordAIHistory(ai) {
  ensureAIHistory(ai);
  const now = new Date();
  const value = calculateAIValue(ai);
  const rap = calculateAIRAP(ai);
  ai.valueHistory.push({ date: now, value });
  ai.rapHistory.push({ date: now, rap });
  // Keep history to last 100 points for performance
  if (ai.valueHistory.length > 100) ai.valueHistory = ai.valueHistory.slice(-100);
  if (ai.rapHistory.length > 100) ai.rapHistory = ai.rapHistory.slice(-100);
}

function recordAllAIHistory() {
  aiUsers.forEach(ai => recordAIHistory(ai));
}

// Start a timer to record all AI histories every 5 minutes
setInterval(recordAllAIHistory, 5 * 60 * 1000);

let aiValueChartInstance = null;
let aiRAPChartInstance = null;
function renderAICharts(ai) {
  ensureAIHistory(ai);
  const valueCtx = document.getElementById('ai-value-history-chart').getContext('2d');
  const rapCtx = document.getElementById('ai-rap-history-chart').getContext('2d');
  if (aiValueChartInstance) aiValueChartInstance.destroy();
  if (aiRAPChartInstance) aiRAPChartInstance.destroy();
  const valueHistory = ai.valueHistory || [];
  const rapHistory = ai.rapHistory || [];
  const valueLabels = valueHistory.map(e => new Date(e.date).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}));
  const valueData = valueHistory.map(e => e.value);
  aiValueChartInstance = new Chart(valueCtx, {
    type: 'line',
    data: {
      labels: valueLabels,
      datasets: [{
        label: 'Value',
        data: valueData,
        borderColor: 'var(--primary-blue)',
        backgroundColor: 'rgba(0,162,255,0.1)',
        fill: true,
        tension: 0.1,
        pointRadius: 2,
        pointBackgroundColor: 'var(--primary-blue)'
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: { legend: { display: false } },
      scales: {
        y: { ticks: { color: 'white' }, grid: { color: 'rgba(255,255,255,0.2)' } },
        x: { ticks: { color: 'white' }, grid: { display: false } }
      }
    }
  });
  const rapLabels = rapHistory.map(e => new Date(e.date).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}));
  const rapData = rapHistory.map(e => e.rap);
  aiRAPChartInstance = new Chart(rapCtx, {
    type: 'line',
    data: {
      labels: rapLabels,
      datasets: [{
        label: 'RAP',
        data: rapData,
        borderColor: 'var(--rap-yellow)',
        backgroundColor: 'rgba(255,204,0,0.1)',
        fill: true,
        tension: 0.1,
        pointRadius: 2,
        pointBackgroundColor: 'var(--rap-yellow)'
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: { legend: { display: false } },
      scales: {
        y: { ticks: { color: 'white' }, grid: { color: 'rgba(255,255,255,0.2)' } },
        x: { ticks: { color: 'white' }, grid: { display: false } }
      }
    }
  });
}

function calculateItemTrend(item) {
    if (!item.stats || !item.stats.valueHistory || item.stats.valueHistory.length < 3) {
        return 1.0; // Neutral trend if not enough data
    }
    const recentHistory = item.stats.valueHistory.slice(-3);
    const oldest = recentHistory[0].value;
    const newest = recentHistory[recentHistory.length - 1].value;

    if (oldest === 0) return 1.0;

    const trend = newest / oldest;

    if (trend > 1.1) return 1.15; // Strong upward trend
    if (trend > 1.0) return 1.05; // Slight upward trend
    if (trend < 0.9) return 0.9;  // Strong downward trend
    if (trend < 1.0) return 0.95; // Slight downward trend
    return 1.0; // Stable
}

function getPerceivedValue(item) {
    if (!item) return 0;
    let perceivedValue = item.value;

    // 1. Stock Multiplier
    const stock = item.initialStock;
    if (stock <= 10) perceivedValue *= 1.4;       // Extremely rare
    else if (stock <= 50) perceivedValue *= 1.25;  // Very rare
    else if (stock <= 250) perceivedValue *= 1.1;   // Rare
    
    // 2. Demand Multiplier
    const demand = calculateDemand(item);
    if (demand === "Very High") perceivedValue *= 1.2;
    else if (demand === "High") perceivedValue *= 1.1;
    else if (demand === "Low") perceivedValue *= 0.9;
    else if (demand === "Very Low") perceivedValue *= 0.8;

    // 3. Trend Multiplier
    perceivedValue *= calculateItemTrend(item);

    // 4. Trophy Item Multiplier
    if (item.value > 25000) {
        perceivedValue *= 1.15; // Extra desire for high-tier items
    }

    // 5. Novelty Multiplier (for newer items)
    if(item.createdAt) {
      const ageInDays = (new Date() - new Date(item.createdAt)) / (1000 * 60 * 60 * 24);
      if (ageInDays < 7) { // Less than a week old
          perceivedValue *= 1.1;
      }
    }

    return Math.floor(perceivedValue);
}
  </script>
</body>
</html>
